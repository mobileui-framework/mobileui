/*
 Copyright (c) 2018 Gustavo Gretter, http://www.mobileui.org

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
-----------------------------------------------------------------
 */
/******************************************************************************
 * Object MobileUI
 ******************************************************************************/
var mui = new (function() {
	this.version = {
			major : 0,
			minor : 12,
			maintenance : 1,
			toString : function() {
				return this.major + "." + this.minor + "." + this.maintenance;
			}
		};
	//Reference to himself
	//Referencia a sí mismo
	var me = this;

	//Add method to jQuery to get correct width when box-sizing: border-box
	$.fn.extend({
		$width: function() {
			var w;
			var obj = $(this[0]);
			try {
				w = obj.css('width');
				if (w && w.endsWith('px')) w=w.substring(0, w.length-2);
				else w = obj.with();
			} catch (err) {
				w = obj.$width();
			}
			return w;
		}
	});

	//Efectos de transición de página por defecto para cada plataforma.
	this.DEF_ANDROID_EFFECT='NONE';
	this.DEF_IOS_EFFECT='OVERFLY_IN';
	this.DEF_WIN_EFFECT='OVERFLY_IN';
	this.DEF_WEBAPP_EFFECT='OVERFLY_IN';
	
	/**
	 * Return the default platform effect for page transition.
	 * Retorna el efecto por defecto para la plataforma.
	 * @returns
	 */
	this.getDefaultPlatformEffect = function() {
		var effect;
		if (mui.isMobileDevice.Android()) effect = mui.DEF_ANDROID_EFFECT;
		else if (mui.isMobileDevice.iOS()) effect = mui.DEF_IOS_EFFECT;
		else if (mui.isMobileDevice.Windows()) effect = mui.DEF_WIN_EFFECT;
		else effect = mui.DEF_WEBAPP_EFFECT; 
		return effect;
	};
	
	//Registered Viewports
	//Viewports registrados
	var viewports = new Array(); 
	
	/**
	 * Creates and registers a Viewport. Return the Viewport object.
	 * Crea y registra un Viewport. Retorna un objeto Viewport.
	 */
	this.createViewport = function(viewportId, currentPageId) {
		for (var x=0; x<viewports.length; x++) {
			vp = viewports[x];
			if (vp.viewportId==viewportId) return vp; 
		}
		var viewportObj = new Viewport(viewportId, currentPageId);
		viewports.push(viewportObj);
		return viewportObj;
	};
	
	/**
	 * Registers a Viewport object created externally
	 * Registrar un objeto Viewport creado externamente. 
	 */
	this.registerViewport = function(viewportObj) {
		for (var x=0; x<viewports.length; x++) {
			vp = viewports[x];
			if (vp.viewportId==viewportObj.viewportId) return vp; 
		}
		viewports.push(viewportObj);
		return viewportObj; 
	};
	
	/**
	 * Remove a registerd
	 * Elimina un viewport registrado.
	 */
	this.removeViewport = function(viewportId) {
		var vp;
		for (var x=0; x<viewports.length; x++) {
			vp = viewports[x];
			//vp.removeScroll();
			if (vp.viewportId==viewportId) viewports.splice(x,1); 
		}
	};
	
	/**
	 * Returns an specific registered Viewport.
	 * Retorna un Viewport registrado específico.
	 */
	this.getViewport = function(viewportId) {
		var ret = null;
		var vp;
		for (var x=0; x<viewports.length; x++) {
			vp = viewports[x];
			if (vp.viewportId==viewportId) ret = vp; 
		}
		return ret;
	};
	
	/**
	 * Return an Array of Viewport objects with all Viewports registered.
	 * Retrona un Array de objetos Viewport con todos los Viewports registrados.
	 */
	this.getAllViewports = function() {
		return viewports;
	};
	
	/**
	 * Return if is a mobile device and its platform
	 * Example: mui.isMobileDevice.any() for query if its a any device mobile or mui.isMobileDevice.iOS() for query if its a iPhone or iPad device.
	 * 
	 */
	this.isMobileDevice = {
			Android: function() {
		        return navigator.userAgent.match(/Android/i)&&!me.isMobileDevice.Windows() ? true : false;
		    },
		    BlackBerry: function() {
		        return navigator.userAgent.match(/BlackBerry/i)&&!me.isMobileDevice.Windows() ? true : false;
		    },
		    iOS: function() {
		        return navigator.userAgent.match(/iPhone|iPad|iPod/i)&&!me.isMobileDevice.Windows() ? true : false;
		    },
		    Windows: function() {
		        return navigator.userAgent.match(/IEMobile/i) ? true : false;
		    },
		    any: function() {
		        return (me.isMobileDevice.Android() || me.isMobileDevice.BlackBerry() || me.isMobileDevice.iOS() || me.isMobileDevice.Windows());
		    }
		};
	
	/**
	 * Return true if window orientation is portrait.
	 */
	this.isPortrait = function() {
		var o = me.getWindowOrientation();
		return o==0 || o==180;
	};
	
	/**
	 * Return true if window orientation is landscape.
	 */
	this.isLandscape = function() {
		var o = me.getWindowOrientation();	
		return o==90|| o==-90;
	};
	
	/**
	 * Return true if device is a tablet.
	 * 
	 * Retorna true si el dispositivo es una tablet.
	 */
	this.isTablet = function() {
		return (navigator.userAgent.match(/iPad/i) ? true : false || (me.isMobileDevice.Android() && screen.width<1000));
	};
	
	/**
	 * Return true is device is a phone.
	 * 
	 * Retorna true si el dispositivo es un teléfono.
	 */
	this.isPhone = function() {
		return !me.isTablet();
	};
	
	/**
	 * Return de window orientation.
	 * Return 90 and -90 => landscape, 0 and 180 => portrait
	 */
	this.getWindowOrientation = function() {
		if ("orientation" in window && !me.isMobileDevice.Windows()) {
			return window.orientation;
		} else {
			return ($(window).width() > $(window).height())? 90 : 0;
		}
	};
	
	/**
	 * Return true if phonegap/cordova is available.
	 * Useful to check if we are in an App or WebApp.
	 */
	this.cordovaAvailable = function() {
	    return "PhoneGap" in window || "cordova" in window;
	};
	
	/**
	 * Return the Cordova/Phonegap object. 
	 */
	this.cordova = function() {
	    if ("PhoneGap" in window)
	        return window.PhoneGap;
	    else if ("cordova" in window)
	        return window.cordova;
	    else 
	    	return null;
	};
	
	/**
	 * Shows a custom alert or dialog box.
	 * Title and buttonName aren't considered in Windows Phone.
	 * 
	 * Presenta una alerta en un cuadro de diálogo.
	 * Title y buttonName no son tenidos en cuenta en Windows Phone.
	 */
	this.alert = function (message, title, buttonName, callback ) {
		if (me.cordovaAvailable() && ("notification" in navigator) && !me.isMobileDevice.Windows()) {
			navigator.notification.alert(message, callback, title, buttonName);
		} else {
			alert(message);
			if (typeof callback == 'function') callback();
		}
	};
	
	/**
	 * Show a native Toast (a little text popup with auto hide). It's great for showing a non intrusive native notification.
	 * Requires toast plugin. If it's not present, mui.alert is used.
	 * 
	 * Muestra un Toast nativo (un pequeño popup de texto con ocultamiento automático). Es ideal para mostrar una notificación nativa no intrusiva.
	 * Requiere toast plugin. Si no está presente, se utiliza mui.alert.
	 * 
	 * position: 'top', 'center', 'bottom'. Default 'center'.
	 * duration: 'short', 'long'. Default 'long'.
	 */
	this.toast = function(message, position, duration) {
		if ("plugins" in window && "toast" in window.plugins)
			window.plugins.toast.show(message, duration, position);
		else
			mui.alert(message);
	};
	
	this.busy = function(isBusy, elementId) {
		try {
			var eId;
			if (typeof elementId=='undefined') eId = "body";
			else eId = elementId;
			if (isBusy) $(eId).jqwait('show');
			else $(eId).jqwait('hide');
		} catch(err) {}
	};
	
	/**
	 * Displays a customizable confirmation dialog box.
	 * confirmCallback receive a parameter corresponding to the index button, 1, 2, 3, etc.
	 * buttonLabels is an array of strings specifying button labels. Defaults to [OK,Cancel]
	 * 
	 * Presenta un cuadro de diálogo de confirmación.
	 * confirmCallback recibe un parámetro correspondiente al indice del botón, 1, 2, 3, etc.
	 * buttonLabels es un Array de Strings que especifican etiquetas de los botones. Por defecto es [Aceptar, Cancelar]
	 */
	this.confirm = function (message, confirmCallback, title, buttonLabels) {
		if (me.cordovaAvailable() && navigator.notification && navigator.notification.confirm) {
			navigator.notification.confirm (
			        message, 
			        confirmCallback,
			        title,
			        buttonLabels
			    );
		} else {
			var ret = confirm(message);
			var buttonIndex = ret?1:2;
			confirmCallback(buttonIndex);
		}	
	};
	this.prompt = function (message, promptCallback, title, buttonLabels, defaultText) {
		var def = (defaultText==undefined?'':defaultText);
		if (me.cordovaAvailable() && navigator.notification && navigator.notification.prompt) {
			navigator.notification.prompt(
					message,
					promptCallback,
					title,
					buttonLabels,
					def
				);
		} else {
			var ret = prompt(message, def);
			var result = {};
			result.input1 = ret;
			if (ret==null) result.buttonIndex=2;
			else result.buttonIndex=1;
			promptCallback(result);
		}
	};
	
	this.beep = function(times) {
		if (me.cordovaAvailable()) {
			if (times==undefined) navigator.notification.beep(1);
			else navigator.notification.beep(times);
		}
	};
	
	this.vibrate = function(milliSeconds) {
		if (me.cordovaAvailable() &&  "vibrate" in navigator) {
			if (milliSeconds==undefined) navigator.vibrate(2500);
			else navigator.notification.vibrate(milliSeconds);
		}
	};
	/**
	 * Creates a link and clicks on it.
	 * Crear un link y hacer click sobre él.
	 * @param href
	 * @param target
	 * @param text
	 */
	this.createAndClickHref = function(href, target, text) {
		var a = document.createElement('a');
		a.setAttribute('href',href);
		if (target) a.setAttribute('target',target);
		if (text) a.innerHTML=text;
		document.getElementsByTagName('body')[0].appendChild(a);
		var mouseEvent = a.ownerDocument.createEvent('MouseEvents');
		mouseEvent.initMouseEvent('click', true, true, a.ownerDocument.defaultView, 1, 0, 0, 0, 0, false, false, false, false, 0, null);
		a.dispatchEvent(mouseEvent);
		document.getElementsByTagName('body')[0].removeChild(a);
	};
	
	this.dialNumber = function(number) {
		me.createAndClickHref('tel:+'+number);
	};
	this.sendSms = function(number, message) {
		me.createAndClickHref('sms:'+number+(me.isMobileDevice.iOS()?';':'?')+'body='+message);
	};
	
	/**
	 * MUI LocalStorage Object
	 */
	this.localStorage = {
			/**
			 * Return an string or object from the localStorage.
			 * Retorna un string u objeto desde el localStorage.
			 */
			get: function(key) {
				var value = window.localStorage.getItem(key);
				try {
					var jsonObj = JSON.parse(value);
					return jsonObj;
				} catch (err) {
					return value;
				}
			},
			/**
			 * Store data into localStorage. If the data type is not string then convert to JSON.
			 * Return de the sotred object, string o JSON as appropriate
			 *  
			 * Almacena un dato en el localStorage. Si el tipo del dato no es string entonces se convierte a JSON.
			 * Retorna el objeto almacenado, string o JSON según corresponda.
			 */
			set: function(key, value) {
				if (typeof value == 'string') {
					window.localStorage.setItem(key, value);
					return value;
				} else {
					var jsonObj = JSON.stringify(value);
					window.localStorage.setItem(key, jsonObj);
					return jsonObj;
				}
			},
			/**
			 * Remove a item from the localStorage.
			 */
			remove: function(key) {
				window.localStorage.removeItem(key);
			},
			/**
			 * Empty the localStorage.
			 * Vacía el localStorage
			 */
			clear: function() {
				window.localStorage.clear();
			}
	};

	/**
	 * MUI SessionStorage Object
	 */
	this.sessionStorage = {
		/**
		 * Return an string or object from the localStorage.
		 * Retorna un string u objeto desde el localStorage.
		 */
		get: function(key) {
			var value = window.sessionStorage.getItem(key);
			try {
				var jsonObj = JSON.parse(value);
				return jsonObj;
			} catch (err) {
				return value;
			}
		},
		/**
		 * Store data into localStorage. If the data type is not string then convert to JSON.
		 * Return de the sotred object, string o JSON as appropriate
		 *  
		 * Almacena un dato en el localStorage. Si el tipo del dato no es string entonces se convierte a JSON.
		 * Retorna el objeto almacenado, string o JSON según corresponda.
		 */
		set: function(key, value) {
			if (typeof value == 'string') {
				window.sessionStorage.setItem(key, value);
				return value;
			} else {
				var jsonObj = JSON.stringify(value);
				window.sessionStorage.setItem(key, jsonObj);
				return jsonObj;
			}
		},
		/**
		 * Remove a item from the localStorage.
		 */
		remove: function(key) {
			window.sessionStorage.removeItem(key);
		},
		/**
		 * Empty the localStorage.
		 * Vacía el localStorage
		 */
		clear: function() {
			window.sessionStorage.clear();
		}
};

	/* Network methods **********************************************************/
	this.connectionAvailable=function() {
		if (me.cordovaAvailable()) {
			var connectionType = me.getConnectionType();
			if (connectionType) return connectionType.toLowerCase()!="none";
			else return false;
		} else {
			return true;	//Asumo que es webapp
		}
	};
	
	/**
	 * Return the connection type:
	 * Retorna el tipo de conexión:
	 * 		Connection.UNKNOWN
	 *		Connection.ETHERNET
	 *		Connection.WIFI
	 *		Connection.CELL_2G
	 *		Connection.CELL_3G
	 *		Connection.CELL_4G
	 *		Connection.CELL
	 *		Connection.NONE
	 *		UNKNOWN is API is not available.
	 */
	this.getConnectionType=function() {
		var connection = navigator.connection?navigator.connection:(navigator.network && navigator.network.connection)?navigator.network.connection:undefined;
		return typeof connection!="undefined"?(connection.type?connection.type:'unknow'):'unknow';
	};  
		
	/**
	 * Return the effective connection types (ECT)
	 *  "2g"
	 *  "3g"
	 *  "4g"
	 *  "slow-2g"
	 */
	this.getConnectionEffectiveType=function() {
		var connection = navigator.connection?navigator.connection:(navigator.network && navigator.network.connection)?navigator.network.connection:undefined;
		return typeof connection!="undefined"?connection.effectiveType:'unknow';
	}
	
	
	/* Nav history methods ****************************************************/
	function muiBackEventListener() {
		me.history.back();
	};
	
	this.history = {
			elements: new Array(),	//Objetos {id, effect, viewport, type [1:page, 2:panel]}
			push: function (id, effect, viewport, type, onBack) {
				//Si es el primer elemento de la pila entonces instalo el evento.
				if (me.history.elements==0 && me.cordovaAvailable()) {
					document.addEventListener("backbutton", muiBackEventListener, false); 
				}
				me.history.elements.push({id:id, effect:effect, viewport:viewport, type:type, onback:onBack});			
			},
			pop: function() {
				var ret = null;
				if (me.history.elements.length>0) {
					ret = me.history.elements.pop();
					if (me.history.elements==0 && me.cordovaAvailable()) {
						document.removeEventListener("backbutton", muiBackEventListener, false);
					}
				}
				return ret;
			},
			pull: function(pageId) {
				for (var x=this.elements.length-1; x>-1; x--) {
					if (this.elements[x].id==pageId) {
						this.elements.splice(x, 1);
						break;
					}
				}
			},
			back: function() {
				var obj = me.history.pop();
				if (obj!=null) {
					if (obj.type==1) {
						var effect;
						switch (obj.effect) {
						case 'NONE':
							effect = 'NONE';
							break;
						case 'FADE':
							effect = 'FADE';
							break;
						case 'SLIDE_RIGHT':
							effect = 'SLIDE_LEFT';
							break;
						case 'SLIDE_LEFT':
							effect = 'SLIDE_RIGHT';
							break;
						case 'SLIDE_UP':
							effect = 'SLIDE_DOWN';
							break;
						case 'SLIDE_DOWN':
							effect = 'SLIDE_UP';
							break;
						case 'OVERFLY_IN':
							effect = 'OVERFLY_OUT';
							break;
						case 'OVERFLY_OUT':
							effect = 'OVERFLY_IN';
							break;
						case 'FLOAT_IN':
							effect = 'FLOAT_OUT';
							break;
						case 'FLOAT_OUT':
							effect = 'FLOAT_IN';
							break;
						default:
							effect = 'NONE';
						}
						obj.viewport.showPage(obj.id, effect, null, null, obj.onback, false, true);
					} else if (obj.type==2) {
						obj.viewport.closePanel(obj.onback, false);
					}
				}
			},
			reset: function() {
				me.history.elements.length=0;
				if (me.cordovaAvailable()) {
					document.removeEventListener("backbutton",  muiBackEventListener, false);
				}
			}
			
	};
	
	this.util = {

		/**
		 * Returns the distance between two points on the earth indicated by its latitude and longitude.
		 * 
		 * Retorna la distancia entre dos puntos de la tierra indicados a través de su latitud y longitud.
		 */
		distanceLatLng: function(lat1,lng1,lat2,lng2,unit) {
			var r;
			if (typeof unit=='undefined' || unit=='K' || unit=='k') r = 6371; // Radius of the earth in km
			else r = 3959; // Radius of the earth in miles
			var d2r = (Math.PI/180);
			var dLat = (lat2-lat1)*d2r; 
			var dLng = (lng2-lng1)*d2r; 
			var a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1*d2r) * Math.cos(lat2*d2r) * Math.sin(dLng/2) * Math.sin(dLng/2); 
			var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
			var d = r * c; // Distance in km or miles
			return d;
		},

		/**
		 * Installs a batch of events.
		 * 
		 * Instala un lote de eventos.
		 * 
		 * e = [
		 *	{
		 *		id: '.mui-page-title',
		 *		[ev: 'dblclick',]		//optional: 'click' default.
		 *		fn: function() {
		 * 			mui.viewport.showPanel('leftmenu','SLIDE_RIGHT');
		 *		}
		 *	},...,
		 *	{
		 *		vp: mui.viewport,	//for ViewPorts events, mui.viewport, mui.screen, etc.
		 *		ev: 'swiperight',
		 *		fn: (currentPageId, originalTarget, event, startX, startY, endX, endY) => {
		 *		
		 *		}
		 *	},
		 *	...
		 * ]
		 */
		installEvents: function(e) {
			for (var i=0;i<e.length;i++) {
				if (e[i].id) $(e[i].id).on((e[i].ev?e[i].ev:'click'),e[i].fn);
				else if (e[i].vp) e[i].vp.on(e[i].ev,e[i].fn);
			}
		},

		loadJS: function (url, callback) {
			if (!isJSLoaded(url)) {
				var tag = document.createElement('script');    
				if (typeof callback==='function') tag.onload = callback;
				tag.src = url;
				document.getElementsByTagName('body')[0].appendChild(tag);
			} else {
				callback();
			}
		},

		isJSLoaded: function(fileName) {
			var list = document.getElementsByTagName('script');
			for (var x=0; x<list.length; x++) {
				if (list[x].src.endsWith(fileName)) return true;
			}
			return false;
		}
	};
	
	/**
	 * Ajax utility
	 */
	this.ajax = function() {	
		var url;
		var data;
		var headers;
		var done;
		var fail;
		var always;
		var param;
		if (typeof arguments[0] == 'string') { 
			url = arguments[0];
			if (typeof arguments[1] == 'object') {
				data = arguments[1];
				if (typeof arguments[2] == 'object') {
					headers = arguments[2];
					done = arguments[3];
					fail = arguments[4];
					always = arguments[5];
				} else {
					done = arguments[2];
					fail = arguments[3];
					always = arguments[4];
				}
			} else {
				done = arguments[1];
				fail = arguments[2];
				always = arguments[3];
			}
			param = {
					url: url,
					crossDomain: true,
					type: "POST",
					dataType: "html",
					data: data,
					headers: headers
				};
		} else {
			param = arguments[0];
			done = arguments[1];
			fail = arguments[2];
			always = arguments[3];
		}
		if (!param.xhrFields) {
			param.xhrFields = {
				withCredentials: true
			}
		}
		
		$.ajax(param)
		 .done(done)
		 .fail(fail)
		 .always(always);
	};
	
	this.fixPlataforms = function() {
		if (me.isMobileDevice.Windows()) {
			window.addEventListener('scroll',function() {
				var dataInterval=null;
				dataInterval = setInterval(function() {
					var tagName=document.activeElement.tagName.toUpperCase();
					var fixWPBounceInFocus = (tagName=="INPUT"||tagName=="TEXTAREA"||tagName=="SELECT");
					if ($("#mui-screen").position().top!=0 && !fixWPBounceInFocus) window.scrollTo(0,0);
					else clearInterval(dataInterval);
				},100);
			});			
		}
		if (me.isMobileDevice.Android()) {
			window.addEventListener('native.keyboardhide', function() {
				$("input[type=text],textarea").blur();
			});
		}
	};
	
});

/*******************************************************
 * Clase Viewport
 *******************************************************/
var Viewport = function(viewportId, currentPageId) {

	var me = this;
	var initialized = false;
	
	this.viewportId = viewportId;
	this.viewportSelector = "#" + viewportId;
	this.$vp = $(this.viewportSelector);
	
	var $cover = null;
	var $lastPanel = null;
	var lastPanelEffect = null;
	var inPageTransition=false;
	var inPanelTransition=false;
	
	// Transition duration in milliseconds
	this.slideDuration = 250; 
	this.fadeDuration = 250;

	this.pages = new Array();
	this.currentPageId = currentPageId;	//The document element id of the current page (Page being showed)
	
	/**
	 * Return the document element id of the current page.
	 */
	this.getCurrentPageId = function() {
		return this.currentPageId;
	};
	
	/**
	 * Return the id of the current open panel or null if there isn't an open panel.
	 * 
	 * Retorna el id del panel abierto o null si no hay ninguno abierto.
	 */
	this.getCurrentPanelId = function() {
		if ($lastPanel!=null) {
			return $lastPanel.attr('id');
		} else return null;
	};
		
	//Define events variables
	var onShowPage;
	var onPreShowPage;
	var onTouchSwipeLeft;
	var onTouchSwipeRight;
	var onTouchSwipeUp;
	var onTouchSwipeDown;
	var onTouchSwipe;
	var onTouchSwipeLeftDiscover;
	var onTouchSwipeRightDiscover;
	var onTouchSwipeUpDiscover;
	var onTouchSwiperDownDiscover;
	var onResize;
	var touchEventsInstalled=false;
	
	var onClosePanelEvent;
	
	this.swipeMinDistance=10;
	this.discoverStripWidth=100;
	
	/**
	 * Install event handlers
	 */
	this.on = function(eventType, eventHandler) {		
		switch (eventType) {
		case 'swipeleft': 
			touchHanlers();
			onTouchSwipeLeft = eventHandler;
			break;
		case 'swiperight':
			touchHanlers();
			onTouchSwipeRight = eventHandler;
			break;
		case 'swipeup': 
			touchHanlers();
			onTouchSwipeUp = eventHandler;
			break;
		case 'swipedown': 
			touchHanlers();
			onTouchSwipeDown = eventHandler;
			break;
		case 'swipe': 
			touchHanlers();
			onTouchSwipe = eventHandler;
			break;
		case 'swipeleftdiscover':
			touchHanlers();
			onTouchSwipeLeftDiscover = eventHandler;
			break;
		case 'swiperightdiscover':
			touchHanlers();
			onTouchSwipeRightDiscover = eventHandler;
			break;
		case 'swipeupdiscover':	//Not implemented. Reserved for future versions
			touchHanlers();
			onTouchSwipeUpDiscover = eventHandler;
			break;
		case 'swipedowndiscover': //Not implemented. Reserved for future versions
			touchHanlers();
			onTouchSwiperDownDiscover = eventHandler;
			break;			
		case 'showpage': 
			onShowPage = eventHandler;
			break;				
		case 'preshowpage': 
			onPreShowPage = eventHandler;
			break;		
			
		default:
			break;
		}
	};

	/**
	 * Private function that install the touch handlers
	 */
	function touchHanlers() {
		if (touchEventsInstalled) return;
		else touchEventsInstalled = true;

		var startX = -1;
		var startY = -1;
		
		var el = document.getElementById(me.viewportId);
		
		el.addEventListener("touchstart", handleStart, false);
		el.addEventListener("MSPointerDown", handleStart, false);
		el.addEventListener("mousedown", handleStart, false);
		
		el.addEventListener("touchend", handleEnd, false);
		el.addEventListener("MSPointerUp", handleEnd, false);
		el.addEventListener("mouseup", handleEnd, false);
		el.addEventListener("touchcancel", handleEnd, false);
		el.addEventListener("MSPointerCancel", handleEnd, false);
		el.addEventListener("mousecancel", handleEnd, false);
		
		function handleStart(event) {
			var touch = event.touches ? event.touches[0] : event;
			startX = touch.pageX;
			startY = touch.pageY;
		}
		
		function handleEnd(event) {
			try {
				if (startX>-1) {
					var touch = event.changedTouches ? event.changedTouches[0] : event;
					var endX = touch.pageX;
					var endY = touch.pageY;
					if (startX!=endX) {	//Ignoring the click event
						var distanceX = Math.abs(startX - endX);
						var distanceY = Math.abs(startY - endY);
						var ratio = distanceY/distanceX;
						var ret = false;
						// Need to move at least swipeMinDistance pixels for real event
						if (distanceX>me.swipeMinDistance || distanceX>me.swipeMinDistance ) {
							if (distanceX>3*distanceY) {	//Horizontal move.
								if (startX>endX) {	//swipeleft
									if (typeof onTouchSwipeLeftDiscover == 'function' && startX>=(me.$vp.$width()-me.discoverStripWidth)) {
										ret = onTouchSwipeLeftDiscover(me.currentPageId, event.srcElement || event.originalTarget, event, startX, startY, endX, endY);
									} else if (typeof onTouchSwipeLeft == 'function') {
										ret = onTouchSwipeLeft(me.currentPageId, event.srcElement || event.originalTarget, event, startX, startY, endX, endY);
									}
								} else {	//swiperight
									if (typeof onTouchSwipeRightDiscover == 'function' && startX<=me.discoverStripWidth) {
										ret = onTouchSwipeRightDiscover(me.currentPageId, event.srcElement || event.originalTarget,event, startX, startY, endX, endY);
									} else if (typeof onTouchSwipeRight == 'function') {
										ret = onTouchSwipeRight(me.currentPageId, event.srcElement || event.originalTarget,event, startX, startY, endX, endY);
									}
								}
							} else if (distanceY>3*distanceX) {	//Vertical move.
								if (startY>endY) { //swipeup
									if (typeof onTouchSwipeUp == 'function') {
										ret = onTouchSwipeUp(me.currentPageId, event.srcElement || event.originalTarget,event, startX, startY, endX, endY);
									}
								} else { //swipedown
									if (typeof onTouchSwipeDown == 'function') {
										ret = onTouchSwipeDown(me.currentPageId, event.srcElement || event.originalTarget,event, startX, startY, endX, endY);
									}
								}
							}
							if (typeof onTouchSwipe == 'function') {
								ret = onTouchSwipe(me.currentPageId, event.srcElement || event.originalTarget,event, startX, startY, endX, endY);
							}
							if (typeof ret=='undefined' || ret) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
					startX=-1;
				}
			} catch (e) {
				//mui.alert(e.message);
			}
		}		
	};
	
	/**
	 * Esta función es invocada cuando comienza el cambio de página.
	 * Si retorna false el proceso se aborta.
	 * @param prevPageId
	 * @param pageId
	 * @param effect
	 * @param parameters
	 * @param isBack
	 * @returns
	 */
	function internalPreShowPage(prevPageId, pageId, effect, parameters, isBack) {
		if (inPageTransition) return false;
		else {
			var ret = true;
			if (typeof onPreShowPage == 'function') ret = onPreShowPage(prevPageId, pageId, effect, parameters, isBack);
			if (ret) inPageTransition = true;
			return ret;
		}
	}
	
	/**
	 * Esta función es invocada cada vez que se presenta una página.
	 * El evento es disparado al finalizar la transición.
	 * @param prevPageId
	 * @param pageId
	 * @param effect
	 * @param parameters
	 * @param isBack
	 * @returns
	 */
	function internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack) {
		inPageTransition=false;
		//Initialize all viewports if not yet been initialized.
		//Inicializar todos los viewports si aún no han sido inicializados.
		var all = mui.getAllViewports();
		for (var x=0; x<all.length; x++) {
			all[x].initialize();
		}
		//If the event is defined run it.
		//Si el evento está definido ejecutarlo.
		if (typeof onShowPage == 'function') onShowPage(prevPageId, pageId, effect, parameters, isBack);
	}

	/**
	 * Show the page identified by the document element id.
	 */
	this.showPage = function(pageId, effect, parameters, onComplete, onBack, prevInHistory, isBack) {
		if (!effect) effect='DEF';
		if (effect=='DEF') effect = mui.getDefaultPlatformEffect();
		if (typeof parameters == 'function') {
			isBack = prevInHistory;
			prevInHistory = onBack;
			onBack = onComplete;
			onComplete = parameters;
		}
		if (pageId != me.currentPageId) {
			//Invoco la previa.
			var prevPageId = me.currentPageId;			
			if (!internalPreShowPage(prevPageId, pageId, effect, parameters, isBack)) return;
			me.currentPageId = pageId;
			var $pageIn = $("#" + pageId);
			var $pageOut = prevPageId?$("#" + prevPageId):$();
			//Si el alto no coincide con el del Viewport lo ajusto.
			if ($pageIn.height()!=me.$vp.height()) $pageIn.height(me.$vp.height());
			switch (effect) {
			case 'NONE':
				$pageOut.css({
					top: '100%',
					left: '100%',
					'z-index': '0',
					visibility: 'hidden'
				});
				$pageIn.css({
					top : '0px',
					left : '0px',
					'z-index': '1',
					visibility: 'visible'
				});
				if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
				internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
				break;
			case 'FADE':
				$pageIn.css({
					'z-index': '0',
					top : '0px',
					left : '0px',
					display: 'block',
					visibility: 'visible'
				});
				$pageOut.fadeOut(this.fadeDuration, function() {
					$pageOut.css({						
						top: '100%',
						left: '100%',
						display: 'block',
						'z-index': '0',
						visibility: 'hidden'
					});
				});
				$pageIn.fadeIn(this.fadeDuration, function() {
					if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
					internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
				});
				break;
			case 'SLIDE_RIGHT':
				// Posiciono la nueva página.
				$pageIn.css({
					'z-index': '1',
					top : '0px',
					left : '-' + me.$vp.$width() + 'px',
					visibility: 'visible'
				});
				$pageIn.animate({
					left : '0px'
				}, this.slideDuration, function() {
					if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
					internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
				});
				$pageOut.animate({
					left : me.$vp.$width() + 'px'
				}, this.slideDuration, function() {
					$pageOut.css({visibility:'hidden','z-index':'0'});
				});
				break;
			case 'SLIDE_LEFT':
				// Posiciono la nueva página.
				$pageIn.css({
					'z-index': '1',
					top : '0px',
					left : me.$vp.$width() + 'px',
					visibility: 'visible'
				});
				$pageIn.animate({
					left : '0px'
				}, this.slideDuration, function() {
					if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
					internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
				});
				$pageOut.animate({
					left : '-' + me.$vp.$width() + 'px'
				}, this.slideDuration, function() {
					$pageOut.css({visibility:'hidden','z-index':'0'});
				});
				break;
			case 'SLIDE_UP':
				// Posiciono la nueva página.
				$pageIn.css({
					'z-index': '1',
					top : me.$vp.height() + 'px',
					left : '0px',
					visibility: 'visible'
				});
				$pageOut.animate({
					top : '-' + me.$vp.height() + 'px'
				}, this.slideDuration, function() {
					$pageOut.css({visibility:'hidden','z-index':'0'});
				});
				$pageIn.animate({
					top : '0px'
				}, this.slideDuration, function() {
					if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
					internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
				});
				break;
			case 'SLIDE_DOWN':
				//Posiciono la nueva página.
				$pageIn.css({
					'z-index': '1',
					top : '-' + me.$vp.height() + 'px',
					left : '0px',
					visibility: 'visible'
				});
				$pageOut.animate({
					top : me.$vp.height() + 'px'
				}, this.slideDuration, function() {
					$pageOut.css({visibility:'hidden','z-index':'0'});
				});
				$pageIn.animate({
					top : '0px'
				}, this.slideDuration, function() {
					if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
					internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
				});
				break;
			case 'OVERFLY_IN':
				$pageOut.css("z-index", "0");
				// Posiciono la nueva página.
				$pageIn.css({
					"z-index": "1",
					top : '0px',
					left : me.$vp.$width() + 'px',
					visibility: 'visible'
				});
				$pageOut.animate({
					left : '-' + me.$vp.$width()/5 + 'px'
				}, this.slideDuration*1.5, function() {
					$pageOut.css({visibility:'hidden'});
				});
				$pageIn.animate({
					left : '0px'
				}, this.slideDuration*1.5, function() {	
					if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
					internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
				});
				break;	
			case 'OVERFLY_OUT':
				$pageOut.css("z-index", "1");
				// Posiciono la nueva página.
				$pageIn.css({
					"z-index": "0",
					top : '0px',
					left: '-' + me.$vp.$width()/5 + 'px',
					visibility: 'visible'
				});
				$pageOut.animate({
					left : me.$vp.$width() + 'px'
				}, this.slideDuration*1.5, function() {
					$pageOut.css({visibility:'hidden','z-index':'0'});
				});
				$pageIn.animate({
					left : '0px'
				}, this.slideDuration*1.5, function() {
					$pageIn.css("z-index", "1");
					if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
					internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
				});
				break;
			case 'FLOAT_IN':
				$pageOut.css("z-index", "0");
				// Posiciono la nueva página.
				$pageIn.css({
					"z-index": "1",
					top : '0px',
					left : me.$vp.$width() + 'px',
					visibility: 'visible'
				});
				$pageIn.animate({
					left : '0px'
				}, this.slideDuration*1.5, function() {
					$pageOut.css({visibility:'hidden'});
					if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
					internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
				});
				break;	
			case 'FLOAT_OUT':
				// Posiciono la nueva página.
				$pageIn.css({
					top : '0px',
					left: '0px',
					visibility: 'visible'
				});
				$pageOut.animate({
					left : me.$vp.$width() + 'px'
				}, this.slideDuration*1.5, function() {
					$pageIn.css('z-index', '1');
					$pageOut.css({visibility:'hidden','z-index':'0'});
					if (typeof onComplete == 'function') onComplete(prevPageId, pageId, effect, parameters, isBack);
					internalCompleteShowPage(prevPageId, pageId, effect, parameters, isBack);
				});
				break;
			}
			if ((prevInHistory == undefined || prevInHistory == true) && (typeof prevPageId!='undefined' && prevPageId.length>0)) {
				mui.history.push(prevPageId, effect, this, 1, onBack);
			}
			this.refreshScroll();
		}
	};

	
	function internalPreShowPanel(currentPage, panelId, effect) {
		if (inPanelTransition) return false;
		else {
			inPanelTransition = true;
			return true;
		}
	};
	
	function internalCompleteShowPanel(currentPage, panelId, effect) {
		inPanelTransition=false;
		//Initialize all viewports if not yet been initialized.
		//Inicializar todos los viewports si aún no han sido inicializados.
		var all = mui.getAllViewports();
		for (var x=0; x<all.length; x++) {
			all[x].initialize();
		}
	};

	this.centerElement = function(element, container) {
		if (typeof container == "undefined") center$Element($(element));
		else me.center$Element($('#'+element), $('#'+container));
	};
	
	this.center$Element = function($element, $container) {
		if (typeof $container=="undefined") $container=me.$vp;
		$element.css({left:(($container.$width()-$element.$width())/2) + 'px',top: (($container.height()-$element.height())/2) +'px'});
	};
	
	this.showPanel = function(panelId, effect, onComplete, onClose, inHistory) {
		if ($lastPanel == null) {
			if (!internalPreShowPanel(this.currentPage, panelId, effect)) return;
			this.putCoverShield(null, function() {
				me.closePanel(function(){
					//onClose();	//Lo hace el onclose
				});
			});
			var panelIn = "#" + panelId;
			$lastPanel = $(panelIn);
			var $pageOut = $("#" + this.currentPageId);
			switch (effect) {
			case 'NONE':
				$lastPanel.css({
					display: 'block',
				});
				internalCompleteShowPanel(this.currentPage, panelId, effect);
				if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
				break;
			case 'FADE':
				$lastPanel.css({
					display: 'none'
				});
				$lastPanel.fadeIn(this.fadeDuration, function() {
					internalCompleteShowPanel(this.currentPage, panelId, effect);
					if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
				});
				break;
			case 'SLIDE_RIGHT':
				// Posiciono la nueva página.
				$lastPanel.css({
					left : (-1 * $lastPanel.$width()) + 'px',
					visibility: "visible"
				}).animate({
					left : '0px'
				}, this.slideDuration);
				$pageOut.animate({
					left : $lastPanel.$width() + 'px'
				}, this.slideDuration, function() {
					internalCompleteShowPanel(this.currentPage, panelId, effect);
					if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
				});
				break;
			case 'SLIDE_LEFT':
				// Posiciono la nueva página.
				$lastPanel.css({
					left : me.$vp.$width() + 'px',
					visibility: "visible"
				});
				$lastPanel.animate({
					left : (me.$vp.$width() - $lastPanel.$width()) + 'px'
				}, this.slideDuration);
				$pageOut.animate({
					left : (-1 * $lastPanel.$width()) + 'px'
				}, this.slideDuration, function() {
					internalCompleteShowPanel(this.currentPage, panelId, effect);
					if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
				});
				break;
			case 'FLOAT_RIGHT':
				// Posiciono la nueva página.
				$lastPanel.css({
					left : (-1 * $lastPanel.$width()) + 'px',
					visibility: "visible"
				}).animate({
					left : '0px'
				}, this.slideDuration, function() {
					internalCompleteShowPanel(this.currentPage, panelId, effect);
					if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
				});
				break;
			case 'FLOAT_LEFT':
				$lastPanel.css({
					left : me.$vp.$width() + 'px',
					visibility: "visible"
				}).animate({
					left : (me.$vp.$width() - $lastPanel.$width()) + 'px'
				}, this.slideDuration, function() {
					internalCompleteShowPanel(this.currentPage, panelId, effect);
					if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
				});
				break;
			case 'SLIDE_UP':
				// Posiciono la nueva página.
				$lastPanel.css({
					top : me.$vp.height() + 'px',
					visibility: "visible"
				}).animate({
					top : (me.$vp.height() - $lastPanel.height()) + 'px'
				}, this.slideDuration);
 				$pageOut.animate({
					top : (-1 * $lastPanel.height()) + 'px'
				}, this.slideDuration, function() {
					internalCompleteShowPanel(this.currentPage, panelId, effect);
					if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
				});
				break;
			case 'SLIDE_DOWN':
				// Posiciono la nueva página.
				$lastPanel.css({
					top : (-1 * $lastPanel.height()) + 'px',
					visibility: "visible"
				}).animate({
					top : '0px'
				}, this.slideDuration);
				$pageOut.animate({
					top : ($lastPanel.height()) + 'px'
				}, this.slideDuration, function() {
					internalCompleteShowPanel(this.currentPage, panelId, effect);
					if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
				});
				break;
			case 'FLOAT_UP':
				$lastPanel.css({
					top : me.$vp.height() + 'px',
					visibility: "visible"
				});
				$lastPanel.animate({
					top : (me.$vp.height() - $lastPanel.height()) + 'px',
				}, this.slideDuration, function() {
					internalCompleteShowPanel(this.currentPage, panelId, effect);
					if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
				});
				break;
			case 'FLOAT_DOWN':
				$lastPanel.css({
					top : (-1 * $lastPanel.height()) + 'px',
					visibility: "visible"
				}).animate({
					top : '0px'
				}, this.slideDuration, function() {
					internalCompleteShowPanel(this.currentPage, panelId, effect);
					if (typeof onComplete == 'function') onComplete(this.currentPage, panelId, effect);
				});
				break;
			default:
				return;
			}
			if (inHistory == undefined || inHistory == true) {
				mui.history.push(panelId, effect, this, 2);
			}
			lastPanelEffect = effect;
			onClosePanelEvent=onClose;
			me.refreshScroll();
		}

	};

	this.panelIsOpen = function() {
		return $lastPanel != null;
	};
	
	this.closePanel = function(complete, removeHistory) {
		if (me.panelIsOpen() && !inPanelTransition) {
			inPanelTransition=true;
			me.removeCoverShield();
			var $pageIn = $("#" + this.currentPageId);
			var lastPanelId = $lastPanel.attr('id');
			switch (lastPanelEffect) {
			case 'NONE':
				$lastPanel.css({
					display: 'none',
				});
				me.removeCoverShield();
				inPanelTransition=false;
				if (typeof onClosePanelEvent == 'function') onClosePanelEvent(this.currentPage, lastPanelId, lastPanelEffect);
				if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
				break;
			case 'FADE':
				$lastPanel.fadeOut(this.fadeDuration, function() {
					inPanelTransition=false;
					if (typeof onClosePanelEvent == 'function') onClosePanelEvent(this.currentPage, lastPanelId, lastPanelEffect);
					if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
				});
				break;
			case 'SLIDE_RIGHT':
				$pageIn.animate({
					left : '0px'
				}, this.slideDuration);
				$lastPanel.animate({
					left : (-1 * $lastPanel.$width()) + 'px',
				}, this.slideDuration, function() {
					$(this).css("visibility", "hidden");
					inPanelTransition=false;
					if (typeof onClosePanelEvent == 'function') onClosePanelEvent(this.currentPage, lastPanelId, lastPanelEffect);
					if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
				});

				break;
			case 'SLIDE_LEFT':			
				// Posiciono la nueva página.
				$($pageIn).animate({
					left : '0px'
				}, this.slideDuration);
				$lastPanel.animate({
					top : '0px',
					left : me.$vp.$width() + 'px',
				}, this.slideDuration, function() {
					$(this).css("visibility", "hidden");
					inPanelTransition=false;
					if (typeof onClosePanelEvent == 'function') onClosePanelEvent(this.currentPage, lastPanelId, lastPanelEffect);
					if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
				});
				break;
			case 'FLOAT_RIGHT':
				$lastPanel.animate({
					left : (-1 * $lastPanel.$width()) + 'px',
				}, this.slideDuration, function() {
					$(this).css("visibility", "hidden");
					inPanelTransition=false;
					if (typeof onClosePanelEvent == 'function') onClosePanelEvent(this.currentPage, lastPanelId, lastPanelEffect);
					if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
				});
				break;
			case 'FLOAT_LEFT':
				$lastPanel.animate({
					left : me.$vp.$width() + 'px',
				}, this.slideDuration, function() {
					$(this).css("visibility", "hidden");
					inPanelTransition=false;
					if (typeof onClosePanelEvent == 'function') onClosePanelEvent(this.currentPage, lastPanelId, lastPanelEffect);
					if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
				});
				break;
			case 'SLIDE_UP':
				$lastPanel.animate({
					top : me.$vp.height() + 'px'
				}, this.slideDuration, function() {
					$(this).css("visibility", "hidden");
					inPanelTransition=false;
					if (typeof onClosePanelEvent == 'function') onClosePanelEvent(this.currentPage, lastPanelId, lastPanelEffect);
					if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
				});
				$pageIn.animate({
					top : '0px'
				}, this.slideDuration);
				break;
			case 'SLIDE_DOWN':
				$pageIn.animate({
					top : '0px'
				}, this.slideDuration);
				$lastPanel.animate({
					top : (-1 * $lastPanel.height()) + 'px'
				}, this.slideDuration, function() {
					$(this).css("visibility", "hidden");
					inPanelTransition=false;
					if (typeof onClosePanelEvent == 'function') onClosePanelEvent(this.currentPage, lastPanelId, lastPanelEffect);
					if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
				});
				break;
			case 'FLOAT_UP':
				$lastPanel.animate({
					top : me.$vp.height() + 'px'
				}, this.slideDuration, function() {
					$(this).css("visibility", "hidden");
					inPanelTransition=false;
					if (typeof onClosePanelEvent == 'function') onClosePanelEvent(this.currentPage, lastPanelId, lastPanelEffect);
					if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
				});
				break;
			case 'FLOAT_DOWN':
				$lastPanel.animate({
					top : (-1 * $lastPanel.height()) + 'px'
				}, this.slideDuration, function() {
					$(this).css("visibility", "hidden");
					inPanelTransition=false;
					if (typeof onClosePanelEvent == 'function') onClosePanelEvent(this.currentPage, lastPanelId, lastPanelEffect);
					if (typeof complete == 'function') complete(this.currentPage, lastPanelId, lastPanelEffect);
				});
				break;
			default:
				return;
			}
			$lastPanel = null;
			if (removeHistory == undefined || removeHistory == true) mui.history.pop();
		} else {
			if (typeof complete==='function') complete(this.currentPage, null, null);
		}
	};

	/**
	 * Use installScroll.
	 * @deprecated
	 */
	this.useIScroll = function(iScrollArg) {
		if (document.addEventListener && mui.isMobileDevice.any() && mui.useIScroll) {	//Navegadores modernos.
			var scrollArg;
			var scrollArgNotUseTransform;
			if (iScrollArg == undefined) {
				//Si es Android versión 2.xxx entonces uso useTransform en false
				var auxTransform = true;
				var ua = navigator.userAgent;
				if( ua.indexOf("Android") >= 0 ) {
				  var androidversion = parseFloat(ua.slice(ua.indexOf("Android")+8)); 
				  if (androidversion <= 3) auxTransform = false;
				}
				var any = mui.isMobileDevice.any();
				scrollArg = {
					click : false,
					preventDefault : any ? false: false, // false en This is the case for Firefox, Chrome and Safari when testing on a desktop.
					scrollbars : any ? false : true,
					fadeScrollbar :any ? false : true,
					mouseWheel : any ? false : true,
					interactiveScrollbars : any ? false : true,
					keyBindings : any ? false : true,
					useTransform: auxTransform
				};
			} else {
				scrollArg = iScrollArg;
			}
			scrollArgNotUseTransform =  $.extend({}, scrollArg);
			scrollArgNotUseTransform.useTransform = false;
			scrollArgNotUseTransform.useTransition = false;
			$(me.viewportSelector + " .mui-scrollable").each(function() {
				$this = $(this);
				var use = true;
				if ( $this.hasClass('mui-notUseTransform') ) use=false;
				else if ( $this.hasClass('ios-notUseTransform') && mui.isMobileDevice.iOS() ) use=false;
				else if ( $this.hasClass('android-notUseTransform') && mui.isMobileDevice.iOS() ) use=false;
				else if ( $this.hasClass('windows-notUseTransform') && mui.isMobileDevice.iOS() ) use=false;
				if ($this.hasClass("mui-zoomable")) {
					if (use) {
						scrollArg.scrollX=true;
						scrollArg.scrollY=true; 
						scrollArg.freeScroll=true;
						scrollArg.zoom=true;
					} else {
						scrollArgNotUseTransform.scrollX=true;
						scrollArgNotUseTransform.scrollY=true;
						scrollArgNotUseTransform.freeScroll=true;
						scrollArgNotUseTransform.zoom=true;
					}
				} else {
					if (use) scrollArg.zoom=false;
					else scrollArgNotUseTransform.zoom=false;
				}
				
				if ($this.children('.mui-scroll-wrapper').length==0) {
					$this.css("overflow", "hidden");
					$this.children().wrapAll("<div class='mui-scroll-wrapper' />");;
					var iScroll = new IScroll(this, (use?scrollArg:scrollArgNotUseTransform));
					$this.data('iScroll', iScroll);
				}
			});
			document.addEventListener('touchmove', function(e) {
				e.preventDefault();
			}, false);
		} else {
			$(".mui-scrollable").css({
				'overflow-y':'auto',
				'overflow-x':'hidden',
				'-webkit-overflow-scrolling': 'touch'
			});
		}

	};

	/**
	 * Use refreshScroll Instead of this method.
	 * @deprectated 
	 */
	this.iScrollRefresh = function(id) {
		var s;
		if (id == undefined) { //If id is undefined I get all mui-scrollable elements below the viewport
			s = this.viewportSelector + " .mui-scrollable";
		} else { // Else I get all mui-scrollable elements below the page id.
			s = "#" + id + " .mui-scrollable";
		}
		// Obtengo el objeto iScroll y si existe lo refresco.
		$(s).each(function() {
			$this = $(this);
			var iScroll = $this.data('iScroll');
			if (iScroll!=undefined) {
				iScroll.refresh();
			}
		});
	};

	/**
	 * Refreshes the scroll on all elements with class mui-scrollable or, if specifies an id, only on this element.
	 * 
	 * Actualiza el scroll en todos los elementos con clase mui-scrollable o, si se especifica un id, solo en ese elemento.
	 * 
	 * Typical use: mui.viewport.refreshScroll()
	 */
	this.refreshScroll = function(id) {
		this.iScrollRefresh(id);
	};
		
	/**
	 * Installs scroll on all elements with class mui-scrollable.
	 * The parameter scrollArg is dependent of the scroll engine (eg: iScroll).
	 * 
	 * Instala scroll en todos los elementos con clase mui-scrollable.
	 * El parámetro scrollArg es dependiente de la ingeniería de scorll utilizada (ej: iScroll):
	 */
	this.installScroll = function(scrollArg) {
		this.useIScroll(scrollArg);
	};
	
	/**
	 * Uninstall the scroll of all elements.
	 * 
	 * Desinistala el scroll de todos los elementos.
	 */
	this.removeScroll = function(id) {
		var s;
		if (id == undefined) { //If id is undefined I get all mui-scrollable elements below the viewport
			s = this.viewportSelector + " .mui-scrollable";
		} else { // Else I get all mui-scrollable elements below the page id.
			s = "#" + id + " .mui-scrollable";
		}		
		$(s).each(function() {
			$this = $(this);
			var iScroll = $this.data('iScroll');
			if (iScroll!=undefined) {
				iScroll.destroy();
				iScroll=null;
			}
		});
	};
	
	/**
	 * Puts a cover Shield div on the current page avoiding events clicks and others.
	 * The shield is a <div class=cssClass ...> being the default cssClass value, if not specified, mui-cover-shield.
	 * 
	 * Coloca un div escudo sobre la página actual para evitar clicks.
	 * El escuedo es un <div class=cssClass ...>, siendo cssClass='mui-cover-shield' por defecto si no se indica.
	 */
	this.putCoverShield = function(cssClass, onClick) {
		if ($cover == null) {
			$cover = $("<div />");
			me.$vp.append($cover);
		}
		if (onClick != undefined) {
			$cover.click(function() {
				onClick();
			});
		}
		if (cssClass != undefined && cssClass != null) {
			$cover.attr("class", cssClass);
		} else {
			$cover.attr("class", "mui-cover-shield");
		}
		$cover.css({
			position : 'absolute',
			top : '0px',
			left : '0px',
			width:'100%',
			height:'100%',
			display : 'block'
		});
	};

	/**
	 * Remove a cover shield
	 * 
	 * Quita el escudo
	 */
	this.removeCoverShield = function() {
		if ($cover != null) {
			$cover.css({
				left : '100%',
			}).removeClass().unbind('click');
		}
	};
	
	/**
	 * Add blur effect on the current page
	 * 
	 * Añadir efecto de desenfoque a la página actual
	 */
	this.blur = function(cssClass) {
		var css=cssClass!=undefined?cssClass:'mui-blur';
		$("#" + this.currentPageId).addClass(css);
	};
	
	/**
	 * Remove the blur effect
	 * 
	 * Quita el efecto de desenfoque
	 */
	this.unblur = function(cssClass) {
		var css=cssClass!=undefined?cssClass:'mui-blur';
		$("#" + this.currentPageId).removeClass(css);
	};
	
	/**
	 * Used to notify its container viewport resized.
	 * 
	 * Se usa para notificar al viewport que su contenedor cambió de tamaño.
	 */
	this.resize = function() {
		$("#"+me.currentPageId).height(me.$vp.height());
		me.refreshScroll();
	};
	
	this.initialize = function() {
		if (!initialized) {
			if (me.$vp.is(":visible")) {
				initialized = true;
				//Get default page.
				//Obtengo la página por defecto.
				if (typeof me.currentPageId == "undefined") {
					me.currentPageId = me.$vp.find(".mui-page").first().attr("id");
				}
				var aux = me.currentPageId;
				me.currentPageId="";
				this.showPage(aux, 'NONE');
				me.installScroll();
				setTimeout(function() {me.refreshScroll(me.currentPageId);},200);
				//if (typeof onShowPage == 'function') onShowPage(null, me.currentPageId, 'NONE', null, false);
			}
		}
	};

	this.addPage = function(id) {
		me.installScroll();
	}

	this.loadPage = function(id, args) {

	}

	me.initialize();
};

/**
 * Inicio del framework.
 */
mui.startup = function() {
	//Opciones estándares
	var options = {
			standarScreen: true,
			standarViewport: true,
			resize: true,
			standarBackEvent: true,
			useFastclick: false, // mui.isMobileDevice.iOS(),
			useIScroll: false, // mui.isMobileDevice.any()?true:false
	};
	//If preDeviceReady function is defined then invoke it. This can modify the standard options.
	//Si está definida la función preDeviceReady la invoco. Esta puede modificar las opciones estándares.
	if (typeof preDeviceReady == 'function') {
		var newOptions = preDeviceReady(options);
		options = $.extend(options, newOptions);
	}
	if (!options.useIScroll) mui.useIScroll = false
	if (options.useFastclick) FastClick.attach(document.body);
	$(".mui-page, .mui-panel").css("visibility", "hidden");
	if (options.standarScreen) {
		//Sets the size of the viewport Screen. It is important to properly move the keyboard on focus on input element.
		//Establezco el tamaño del viewport Screen. Es importante para que el teclado desplace correctamente la pantalla al hacer foco sobre un input.
		var adjustOrientation = function() {
			$("div#mui-screen").css("width", (window.innerWidth) + "px");
			$("div#mui-screen").css("height", (window.innerHeight) + "px");
			if (mui.screen) mui.screen.resize();
			if (options.standarViewport && mui.viewport)  mui.viewport.resize();
		};
		adjustOrientation();
		if (typeof mui.defaultScreenPage=="undefined") mui.screen = new Viewport('mui-screen');
		else mui.screen = new Viewport('mui-screen', mui.defaultScreenPage);
		mui.registerViewport(mui.screen);
	}
	if (options.standarViewport) {
		if (typeof mui.defaultViewportPage=="undefined") mui.viewport = mui.createViewport('mui-viewport');
		else mui.viewport = mui.createViewport('mui-viewport', mui.defaultViewportPage);
	}
	if (options.resize) {
		var currentWidth = window.innerWidth;
		$(window).resize(function() {
			var lastWidth = window.innerWidth;
			//if (currentWidth!=lastWidth) {	//Orientation changed. La orientación cambió.
				if (options.standarScreen) {
					//Sets the size of the viewport Screen. It is important to properly move the keyboard on focus on input element.
					//Establezco el tamaño del viewport Screen. Es importante para que el teclado desplace correctamente la pantalla al hacer foco sobre un input.
					currentWidth=lastWidth;
					adjustOrientation();
				}
				//Invoke the standard resize events in each viewport, if defined.
				//Invoco los eventos resize en cada viewport estandar, si está definido.
				var all = mui.getAllViewports();
				for (var x=0; x<all.length; x++) all[x].resize();
			//}
		});
	}
	mui.fixPlataforms();
	if (typeof deviceReady == 'function') setTimeout(deviceReady,0);
}

$(document).ready(function() {
	if (mui.cordovaAvailable()) {	//true si es una app nativa.
		document.addEventListener("deviceready", function () {	//evento cordova ready
			mui.startup();
		}, false);
	} else { //web app
		mui.startup();
	}
});
